<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Aura Flow V2 — by Rare Aura Media Group</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              aura: {
                primary: '#7f5af0',
                secondary: '#2cb1bc',
                accent: '#f2a359',
              },
            },
            boxShadow: {
              brand: '0 25px 50px -12px rgba(127, 90, 240, 0.45)',
            },
          },
        },
        safelist: [
          'ring-aura-primary/60',
          'ring-aura-primary/50',
          'ring-offset-2',
          'ring-offset-slate-950',
          'text-aura-primary',
          'bg-aura-primary/10',
          'cursor-grab',
          'cursor-grabbing',
          'opacity-60',
          'opacity-70',
          'text-[0.65rem]',
          'max-w-[8rem]',
          'max-w-[10rem]',
          'animate-pulse',
        ],
      };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <style>
      :root {
        color-scheme: dark;
      }
      body {
        background: radial-gradient(circle at top left, rgba(127, 90, 240, 0.3), transparent 40%),
          radial-gradient(circle at bottom right, rgba(44, 177, 188, 0.25), transparent 45%),
          #0f172a;
      }
      .login-card::before {
        content: '';
        position: absolute;
        inset: 0;
        border-radius: 1.25rem;
        padding: 1px;
        background: linear-gradient(135deg, rgba(127, 90, 240, 0.8), rgba(44, 177, 188, 0.65));
        -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
        -webkit-mask-composite: xor;
        mask-composite: exclude;

      }
      .toast-enter {
        transform: translateY(16px);
        opacity: 0;
      }
      .toast-enter-active {
        transform: translateY(0);
        opacity: 1;
        transition: opacity 0.25s ease, transform 0.25s ease;
      }
      .toast-leave {
        transform: translateY(0);
        opacity: 1;
      }
      .toast-leave-active {
        transform: translateY(-8px);
        opacity: 0;
        transition: opacity 0.2s ease, transform 0.2s ease;
      }
    </style>
  </head>
  <body class="min-h-screen text-slate-100">
    <div class="absolute inset-0 overflow-hidden pointer-events-none" aria-hidden="true">
      <div class="absolute -top-32 -right-32 h-72 w-72 rounded-full bg-aura-primary/30 blur-3xl"></div>
      <div class="absolute -bottom-24 -left-24 h-72 w-72 rounded-full bg-aura-secondary/25 blur-3xl"></div>
    </div>

    <div id="toastStack" class="fixed top-4 right-4 z-[100] flex flex-col gap-3 w-72 pointer-events-none" role="status" aria-live="assertive"></div>

    <main class="relative z-10">
      <section id="loginView" class="min-h-screen flex items-center justify-center px-6 py-12">
        <div class="login-card relative isolate bg-slate-950/70 backdrop-blur-xl border border-white/10 rounded-3xl shadow-brand max-w-xl w-full">
          <div class="absolute inset-x-0 -top-20 mx-auto w-40 h-40 rounded-full bg-gradient-to-br from-aura-primary to-aura-secondary blur-3xl opacity-40"></div>
          <div class="p-10 space-y-10">

            <div>
              <p class="text-sm uppercase tracking-[0.3em] text-slate-400 mb-2">Welcome to</p>
              <h1 class="text-3xl sm:text-4xl font-semibold text-white leading-tight">
                Aura Flow V2 <span class="text-slate-400">— by Rare Aura Media Group</span>
              </h1>
              <p class="mt-4 text-base text-slate-400 leading-relaxed">
                Manage collaborative workstreams, track focus, and surface insights with a refined workflow engine tailored for scaling creative teams.
              </p>
            </div>
            <form id="loginForm" class="space-y-6">
              <div class="grid gap-2">
                <label for="email" class="text-sm font-medium text-slate-200">Work Email</label>
                <input
                  id="email"
                  name="email"
                  type="email"
                  placeholder="you@rareaura.co"
                  required
                  autocomplete="email"
                  class="w-full rounded-xl border border-white/10 bg-slate-900/60 px-4 py-3 text-base text-slate-100 focus:outline-none focus:ring-2 focus:ring-aura-primary focus:border-transparent"

                />
              </div>
              <div class="grid gap-2">
                <label for="password" class="text-sm font-medium text-slate-200">Password</label>
                <input
                  id="password"
                  name="password"
                  type="password"
                  placeholder="••••••••"
                  required
                  autocomplete="current-password"
                  class="w-full rounded-xl border border-white/10 bg-slate-900/60 px-4 py-3 text-base text-slate-100 focus:outline-none focus:ring-2 focus:ring-aura-primary focus:border-transparent"

                />
              </div>
              <button
                id="loginButton"
                type="submit"
                class="group relative w-full inline-flex items-center justify-center gap-2 rounded-xl bg-aura-primary px-4 py-3 text-base font-semibold text-white shadow-lg shadow-aura-primary/30 transition hover:bg-aura-primary/90 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-aura-primary"
              >
                <span data-role="spinner" class="h-5 w-5 border-2 border-white/30 border-t-white rounded-full animate-spin hidden"></span>
                <span data-role="label">Sign in to Aura Flow</span>
              </button>
            </form>
            <div class="grid gap-4 text-sm text-slate-500">
              <div class="flex items-center gap-3">
                <span class="h-px flex-1 bg-white/10"></span>
                <span>Security &amp; Trust</span>
                <span class="h-px flex-1 bg-white/10"></span>
              </div>
              <p>
                Credentials are encrypted via salted SHA-256 hashing. Sessions stay secure with short-lived tokens managed through Google Apps Script CacheService.
              </p>
            </div>
          </div>
        </div>
      </section>

      <section id="appView" class="hidden min-h-screen pb-16">
        <header class="sticky top-0 z-40 bg-slate-950/80 backdrop-blur border-b border-white/5">
          <div class="max-w-7xl mx-auto px-6 py-5 flex flex-col gap-4 lg:flex-row lg:items-center lg:justify-between">
            <div>
              <p class="text-xs uppercase tracking-[0.35em] text-slate-500">Workspace</p>
              <h2 class="text-2xl font-semibold text-white">
                Aura Flow V2 <span class="text-slate-400">— by Rare Aura Media Group</span>
              </h2>
            </div>
            <div class="flex items-center gap-4">
              <div class="text-right">
                <p id="userBadge" class="text-sm font-medium text-white">Authenticated</p>
                <p class="text-xs text-slate-500" id="roleBadge">Role</p>
              </div>
              <button
                id="logoutButton"
                class="inline-flex items-center justify-center rounded-xl border border-white/10 bg-transparent px-4 py-2 text-sm font-medium text-slate-200 transition hover:bg-white/10 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-white/40"
              >
                Logout
              </button>
            </div>
          </div>
          <nav class="border-t border-white/5 bg-slate-950/70">
            <div class="max-w-7xl mx-auto px-4 overflow-x-auto">
              <div class="flex items-center gap-2 py-3" role="tablist">
                <button data-tab-button="dashboard" class="tab-button">Dashboard</button>
                <button data-tab-button="kanban" class="tab-button">Kanban</button>
                <button data-tab-button="analytics" class="tab-button">Analytics</button>
                <button data-tab-button="focus" class="tab-button">Focus</button>
                <button data-tab-button="admin" class="tab-button">Admin</button>
              </div>
            </div>
          </nav>
        </header>
        <div class="max-w-7xl mx-auto px-6 py-12 space-y-12">
          <section data-tab-panel="dashboard" class="tab-panel">
            <div class="grid gap-6 lg:grid-cols-2 xl:grid-cols-4">
              <div class="rounded-2xl bg-slate-900/70 border border-white/5 p-6">
                <div class="flex items-center justify-between gap-3">
                  <p class="text-sm text-slate-400">Tasks Today</p>
                  <span class="text-xs text-slate-500" id="metric-today-context">—</span>
                </div>
                <p class="mt-4 text-4xl font-semibold tracking-tight text-white" id="metric-today">—</p>
                <p class="mt-3 text-xs text-slate-500" id="metric-today-detail">Awaiting workspace sync.</p>
              </div>
              <div class="rounded-2xl bg-slate-900/70 border border-white/5 p-6">
                <div class="flex items-center justify-between gap-3">
                  <p class="text-sm text-slate-400">Completed</p>
                  <span class="text-xs text-slate-500" id="metric-complete-context">—</span>
                </div>
                <p class="mt-4 text-4xl font-semibold tracking-tight text-white" id="metric-complete">—</p>
                <p class="mt-3 text-xs text-slate-500" id="metric-complete-detail">Awaiting workspace sync.</p>
              </div>
              <div class="rounded-2xl bg-slate-900/70 border border-white/5 p-6">
                <div class="flex items-center justify-between gap-3">
                  <p class="text-sm text-slate-400">Time Tracked</p>
                  <span class="text-xs text-slate-500" id="metric-time-context">—</span>
                </div>
                <p class="mt-4 text-4xl font-semibold tracking-tight text-white" id="metric-time">—</p>
                <p class="mt-3 text-xs text-slate-500" id="metric-time-detail">Awaiting workspace sync.</p>
              </div>
              <div class="rounded-2xl bg-slate-900/70 border border-white/5 p-6">
                <div class="flex items-center justify-between gap-3">
                  <p class="text-sm text-slate-400">Overdue</p>
                  <span class="text-xs text-slate-500" id="metric-overdue-context">—</span>
                </div>
                <p class="mt-4 text-4xl font-semibold tracking-tight text-white" id="metric-overdue">—</p>
                <p class="mt-3 text-xs text-slate-500" id="metric-overdue-detail">Awaiting workspace sync.</p>
              </div>
            </div>
            <div class="mt-10 rounded-3xl bg-slate-900/80 border border-white/5 p-8">
              <div class="flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between">
                <div>
                  <h3 class="text-xl font-semibold text-white">Workspace Activity Snapshot</h3>
                  <p class="mt-2 text-sm text-slate-400">Latest updates from the Activity Log.</p>
                </div>
                <span id="activityTimestamp" class="text-xs text-slate-500">—</span>
              </div>
              <div
                id="activityLoading"
                class="mt-6 hidden items-center gap-3 text-sm text-slate-400"
                role="status"
                aria-live="polite"
              >
                <span class="flex h-2.5 w-2.5 items-center justify-center">
                  <span class="h-2.5 w-2.5 animate-ping rounded-full bg-aura-primary/70"></span>
                </span>
                <span>Loading activity…</span>
              </div>
              <div
                id="activityEmpty"
                class="mt-6 hidden rounded-2xl border border-dashed border-white/10 bg-slate-950/50 p-6 text-center text-sm text-slate-400"
              >
                No recent activity
              </div>
              <ul id="activityList" class="mt-6 space-y-3" role="list"></ul>
            </div>
          </section>

          <section data-tab-panel="kanban" class="tab-panel hidden">
            <div class="space-y-8">
              <div class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
                <div>
                  <h3 class="text-2xl font-semibold text-white">Kanban Workspace</h3>
                  <p class="text-sm text-slate-400">
                    Drag tasks across swimlanes to reflect real-time delivery status. Updates sync instantly with the workspace.
                  </p>
                </div>
                <div class="flex items-center gap-2 text-xs text-slate-500">
                  <span class="hidden sm:inline">Statuses:</span>
                  <ul class="flex items-center gap-2">
                    <li class="rounded-full bg-white/5 px-2 py-1 text-[0.7rem] uppercase tracking-wide text-slate-300">Planned</li>
                    <li class="rounded-full bg-white/5 px-2 py-1 text-[0.7rem] uppercase tracking-wide text-slate-300">In-Progress</li>
                    <li class="rounded-full bg-white/5 px-2 py-1 text-[0.7rem] uppercase tracking-wide text-slate-300">Completed</li>
                    <li class="rounded-full bg-white/5 px-2 py-1 text-[0.7rem] uppercase tracking-wide text-slate-300">Shifted</li>
                    <li class="rounded-full bg-white/5 px-2 py-1 text-[0.7rem] uppercase tracking-wide text-slate-300">Cancelled</li>
                  </ul>
                </div>
              </div>
              <div
                id="kanbanLoading"
                class="hidden items-center gap-3 text-sm text-slate-400 sm:flex"
                role="status"
                aria-live="polite"
              >
                <span class="flex h-2.5 w-2.5 items-center justify-center">
                  <span class="h-2.5 w-2.5 animate-ping rounded-full bg-aura-primary/70"></span>
                </span>
                <span>Syncing tasks&hellip;</span>
              </div>
              <div
                id="kanbanEmpty"
                class="hidden rounded-3xl border border-dashed border-white/10 bg-slate-900/60 p-10 text-center"
              >
                <div class="mx-auto flex max-w-md flex-col gap-3">
                  <h4 class="text-lg font-semibold text-white">No tasks yet</h4>
                  <p class="text-sm text-slate-400">
                    When tasks are created they will appear here, ready to be triaged across the workflow.
                  </p>
                </div>
              </div>
              <div
                id="kanbanBoard"
                class="flex gap-4 overflow-x-auto pb-6 snap-x snap-mandatory xl:grid xl:grid-cols-5 xl:gap-6 xl:overflow-visible"
              >
                <div
                  class="kanban-column relative flex min-w-[230px] snap-center flex-col rounded-3xl border border-white/10 bg-slate-950/60 p-5 transition-all duration-200 hover:border-white/20"
                  data-kanban-column="Planned"
                  aria-label="Planned column"
                >
                  <div class="flex items-baseline justify-between gap-3">
                    <div>
                      <h4 class="text-base font-semibold text-white">Planned</h4>
                      <p class="text-xs text-slate-500">Upcoming scope and queued initiatives.</p>
                    </div>
                    <span class="rounded-full bg-white/5 px-2 py-0.5 text-xs font-semibold text-slate-300" data-kanban-count>0</span>
                  </div>
                  <div class="mt-4 flex flex-col gap-3" data-kanban-list role="list" aria-label="Planned tasks"></div>
                </div>
                <div
                  class="kanban-column relative flex min-w-[230px] snap-center flex-col rounded-3xl border border-white/10 bg-slate-950/60 p-5 transition-all duration-200 hover:border-white/20"
                  data-kanban-column="In-Progress"
                  aria-label="In-Progress column"
                >
                  <div class="flex items-baseline justify-between gap-3">
                    <div>
                      <h4 class="text-base font-semibold text-white">In-Progress</h4>
                      <p class="text-xs text-slate-500">Active execution and collaboration.</p>
                    </div>
                    <span class="rounded-full bg-white/5 px-2 py-0.5 text-xs font-semibold text-slate-300" data-kanban-count>0</span>
                  </div>
                  <div class="mt-4 flex flex-col gap-3" data-kanban-list role="list" aria-label="In-Progress tasks"></div>
                </div>
                <div
                  class="kanban-column relative flex min-w-[230px] snap-center flex-col rounded-3xl border border-white/10 bg-slate-950/60 p-5 transition-all duration-200 hover:border-white/20"
                  data-kanban-column="Completed"
                  aria-label="Completed column"
                >
                  <div class="flex items-baseline justify-between gap-3">
                    <div>
                      <h4 class="text-base font-semibold text-white">Completed</h4>
                      <p class="text-xs text-slate-500">Validated deliverables and wins.</p>
                    </div>
                    <span class="rounded-full bg-white/5 px-2 py-0.5 text-xs font-semibold text-slate-300" data-kanban-count>0</span>
                  </div>
                  <div class="mt-4 flex flex-col gap-3" data-kanban-list role="list" aria-label="Completed tasks"></div>
                </div>
                <div
                  class="kanban-column relative flex min-w-[230px] snap-center flex-col rounded-3xl border border-white/10 bg-slate-950/60 p-5 transition-all duration-200 hover:border-white/20"
                  data-kanban-column="Shifted"
                  aria-label="Shifted column"
                >
                  <div class="flex items-baseline justify-between gap-3">
                    <div>
                      <h4 class="text-base font-semibold text-white">Shifted</h4>
                      <p class="text-xs text-slate-500">Rescheduled or deferred scope.</p>
                    </div>
                    <span class="rounded-full bg-white/5 px-2 py-0.5 text-xs font-semibold text-slate-300" data-kanban-count>0</span>
                  </div>
                  <div class="mt-4 flex flex-col gap-3" data-kanban-list role="list" aria-label="Shifted tasks"></div>
                </div>
                <div
                  class="kanban-column relative flex min-w-[230px] snap-center flex-col rounded-3xl border border-white/10 bg-slate-950/60 p-5 transition-all duration-200 hover:border-white/20"
                  data-kanban-column="Cancelled"
                  aria-label="Cancelled column"
                >
                  <div class="flex items-baseline justify-between gap-3">
                    <div>
                      <h4 class="text-base font-semibold text-white">Cancelled</h4>
                      <p class="text-xs text-slate-500">Stopped, rejected, or void work.</p>
                    </div>
                    <span class="rounded-full bg-white/5 px-2 py-0.5 text-xs font-semibold text-slate-300" data-kanban-count>0</span>
                  </div>
                  <div class="mt-4 flex flex-col gap-3" data-kanban-list role="list" aria-label="Cancelled tasks"></div>
                </div>
              </div>
            </div>
          </section>

          <section data-tab-panel="analytics" class="tab-panel hidden">
            <div class="space-y-8">
              <div class="flex flex-col gap-4 sm:flex-row sm:items-end sm:justify-between">
                <div class="space-y-2">
                  <h3 class="text-2xl font-semibold text-white">Analytics &amp; Insights</h3>
                  <p class="text-sm text-slate-400">
                    Track throughput, time allocation, and sentiment with live dashboards sourced from Tasks and Moods services.
                  </p>
                </div>
                <div class="flex items-center gap-3">
                  <span id="analyticsRefreshTime" class="text-xs text-slate-500">Awaiting data…</span>
                  <button
                    id="analyticsRefreshButton"
                    type="button"
                    class="inline-flex items-center gap-2 rounded-xl border border-white/10 bg-white/5 px-4 py-2 text-sm font-medium text-slate-100 transition hover:bg-white/10 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-aura-primary"
                  >
                    <span data-role="spinner" class="hidden h-4 w-4 animate-spin rounded-full border-2 border-white/40 border-t-transparent"></span>
                    <span data-role="label">Refresh</span>
                  </button>
                </div>
              </div>

              <div class="grid gap-6 xl:grid-cols-2">
                <div class="relative overflow-hidden rounded-3xl border border-white/5 bg-slate-900/70 p-6">
                  <div class="flex items-center justify-between gap-2">
                    <div>
                      <p class="text-xs uppercase tracking-[0.3em] text-slate-500">Delivery</p>
                      <h4 class="mt-1 text-lg font-semibold text-white">Completion Velocity</h4>
                    </div>
                    <span id="velocityMetric" class="rounded-full bg-emerald-500/10 px-3 py-1 text-xs font-medium text-emerald-300">—</span>
                  </div>
                  <p class="mt-3 text-sm text-slate-400">Closed tasks across the last 14 days.</p>
                  <div class="mt-6 h-64">
                    <canvas id="completionVelocityChart" role="img" aria-label="Completion velocity line chart"></canvas>
                  </div>
                  <div
                    id="velocityChartEmpty"
                    class="pointer-events-none absolute inset-0 hidden items-center justify-center bg-slate-950/75 px-8 text-center text-sm font-medium text-slate-400 backdrop-blur-sm"
                  >
                    No completed tasks yet — close work to unlock velocity insights.
                  </div>
                </div>

                <div class="relative overflow-hidden rounded-3xl border border-white/5 bg-slate-900/70 p-6">
                  <div class="flex items-center justify-between gap-2">
                    <div>
                      <p class="text-xs uppercase tracking-[0.3em] text-slate-500">Time</p>
                      <h4 class="mt-1 text-lg font-semibold text-white">Time by Category</h4>
                    </div>
                    <span id="categoryMetric" class="rounded-full bg-aura-primary/10 px-3 py-1 text-xs font-medium text-aura-primary/90">—</span>
                  </div>
                  <p class="mt-3 text-sm text-slate-400">Aggregated duration estimates grouped by task category.</p>
                  <div class="mt-6 h-64">
                    <canvas id="timeByCategoryChart" role="img" aria-label="Time by category doughnut chart"></canvas>
                  </div>
                  <div
                    id="categoryChartEmpty"
                    class="pointer-events-none absolute inset-0 hidden items-center justify-center bg-slate-950/75 px-8 text-center text-sm font-medium text-slate-400 backdrop-blur-sm"
                  >
                    Add duration estimates to your tasks to visualize category distribution.
                  </div>
                </div>
              </div>

              <div class="relative overflow-hidden rounded-3xl border border-white/5 bg-slate-900/70 p-6">
                <div class="flex items-center justify-between gap-2">
                  <div>
                    <p class="text-xs uppercase tracking-[0.3em] text-slate-500">Sentiment</p>
                    <h4 class="mt-1 text-lg font-semibold text-white">Mood Trends</h4>
                  </div>
                  <span id="moodMetric" class="rounded-full bg-sky-500/10 px-3 py-1 text-xs font-medium text-sky-300">—</span>
                </div>
                <p class="mt-3 text-sm text-slate-400">Average mood intensity recorded from focus sessions.</p>
                <div class="mt-6 h-64">
                  <canvas id="moodTrendChart" role="img" aria-label="Mood trends line chart"></canvas>
                </div>
                <div
                  id="moodChartEmpty"
                  class="pointer-events-none absolute inset-0 hidden items-center justify-center bg-slate-950/75 px-8 text-center text-sm font-medium text-slate-400 backdrop-blur-sm"
                >
                  Log a focus session to begin charting team sentiment.
                </div>
              </div>
            </div>
          </section>

          <section data-tab-panel="focus" class="tab-panel hidden">
            <div class="grid gap-8 xl:grid-cols-[2fr,1fr]">
              <div class="space-y-8 rounded-3xl border border-white/5 bg-slate-900/70 p-8">
                <div class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
                  <div>
                    <h3 class="text-2xl font-semibold text-white">Focus Mode</h3>
                    <p class="mt-2 text-sm text-slate-400">Run structured Pomodoro sessions that automatically sync activity and mood analytics.</p>
                  </div>
                  <span
                    id="focusStatusBadge"
                    class="inline-flex items-center gap-2 rounded-full border border-white/10 bg-white/5 px-4 py-2 text-xs font-medium text-slate-200"
                  >
                    <span data-role="focus-status-dot" class="h-2.5 w-2.5 rounded-full bg-emerald-400/70"></span>
                    <span data-role="focus-status-text">Ready</span>
                  </span>
                </div>

                <div class="rounded-2xl border border-white/5 bg-slate-950/60 p-8 text-center">
                  <p class="text-xs uppercase tracking-[0.3em] text-slate-500">Current Session</p>
                  <p id="focusTimerDisplay" class="mt-4 text-6xl font-semibold tracking-tight text-white tabular-nums">25:00</p>
                  <p id="focusTimerSubtitle" class="mt-2 text-sm text-slate-400">Default Pomodoro — 25 minutes</p>
                  <div class="mt-6 flex flex-wrap items-center justify-center gap-3">
                    <button
                      id="focusStartButton"
                      type="button"
                      class="inline-flex items-center justify-center rounded-full bg-emerald-500 px-6 py-2 text-sm font-semibold text-emerald-950 shadow-lg shadow-emerald-500/30 transition hover:bg-emerald-400 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-emerald-300"
                    >
                      Start
                    </button>
                    <button
                      id="focusPauseButton"
                      type="button"
                      class="inline-flex items-center justify-center rounded-full border border-white/10 bg-white/5 px-6 py-2 text-sm font-semibold text-slate-200 transition hover:bg-white/10 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-white/40"
                    >
                      Pause
                    </button>
                    <button
                      id="focusResetButton"
                      type="button"
                      class="inline-flex items-center justify-center rounded-full border border-white/10 bg-white/5 px-6 py-2 text-sm font-semibold text-slate-200 transition hover:bg-white/10 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-white/40"
                    >
                      Reset
                    </button>
                  </div>
                </div>

                <div class="grid gap-6 md:grid-cols-2">
                  <label class="grid gap-2">
                    <span class="text-sm font-medium text-slate-200">Session Length (minutes)</span>
                    <input
                      id="focusDurationInput"
                      type="number"
                      min="5"
                      max="90"
                      step="5"
                      value="25"
                      class="rounded-xl border border-white/10 bg-slate-950/60 px-4 py-3 text-base text-slate-100 focus:outline-none focus:ring-2 focus:ring-aura-primary"
                    />
                    <span class="text-xs text-slate-500">Default Pomodoro cadence. Adjust before you start.</span>
                  </label>
                  <label class="grid gap-2">
                    <span class="text-sm font-medium text-slate-200">Anchor Task</span>
                    <select
                      id="focusTaskSelect"
                      class="rounded-xl border border-white/10 bg-slate-950/60 px-4 py-3 text-base text-slate-100 focus:outline-none focus:ring-2 focus:ring-aura-primary"
                    >
                      <option value="">Select a task</option>
                    </select>
                    <span class="text-xs text-slate-500">Link your focus block to a task for logging.</span>
                  </label>
                  <label class="grid gap-2 md:col-span-2">
                    <span class="text-sm font-medium text-slate-200">How are you arriving to this session?</span>
                    <select
                      id="focusMoodSelect"
                      class="rounded-xl border border-white/10 bg-slate-950/60 px-4 py-3 text-base text-slate-100 focus:outline-none focus:ring-2 focus:ring-aura-primary"
                    >
                      <option value="focused">Focused</option>
                      <option value="energized">Energized</option>
                      <option value="neutral" selected>Neutral</option>
                      <option value="calm">Calm</option>
                      <option value="stressed">Stressed</option>
                      <option value="drained">Drained</option>
                    </select>
                    <span class="text-xs text-slate-500">We’ll record this mood when the timer completes.</span>
                  </label>
                </div>

                <div>
                  <div class="flex items-center justify-between gap-2">
                    <h4 class="text-sm font-semibold text-white">Recent Sessions</h4>
                    <button id="focusClearHistoryButton" type="button" class="text-xs text-slate-500 transition hover:text-slate-300">
                      Clear
                    </button>
                  </div>
                  <div
                    id="focusHistoryEmpty"
                    class="mt-4 rounded-2xl border border-dashed border-white/10 bg-slate-950/40 p-6 text-center text-sm text-slate-500"
                  >
                    Completed focus sessions will appear here.
                  </div>
                  <ul id="focusHistoryList" class="mt-4 hidden space-y-3 text-sm text-slate-300"></ul>
                </div>
              </div>

              <aside class="space-y-6 rounded-3xl border border-white/5 bg-slate-900/50 p-8">
                <div>
                  <h4 class="text-lg font-semibold text-white">Flow Tips</h4>
                  <p class="mt-2 text-sm text-slate-400">Prime your environment, celebrate each win, and recharge between cycles.</p>
                </div>
                <div class="grid gap-4 text-sm text-slate-400">
                  <div class="rounded-2xl border border-white/10 bg-slate-950/40 p-4">
                    <p class="font-medium text-slate-200">Cycle cadence</p>
                    <p class="mt-1 text-slate-400">Run four Pomodoros with short breaks for sustained momentum.</p>
                  </div>
                  <div class="rounded-2xl border border-white/10 bg-slate-950/40 p-4">
                    <p class="font-medium text-slate-200">Data sync</p>
                    <p class="mt-1 text-slate-400">Session completions automatically trigger mood and activity logging.</p>
                  </div>
                  <div class="rounded-2xl border border-white/10 bg-slate-950/40 p-4">
                    <p class="font-medium text-slate-200">Break rituals</p>
                    <p class="mt-1 text-slate-400">Stretch, hydrate, or capture a quick insight before diving back in.</p>
                  </div>
                </div>
              </aside>
            </div>
          </section>

          <section data-tab-panel="admin" class="tab-panel hidden">
            <div class="rounded-3xl bg-slate-900/70 border border-white/5 p-8">
              <h3 class="text-2xl font-semibold text-white">Admin Control Center</h3>
              <p class="mt-4 text-sm text-slate-400">
                User provisioning, hierarchy management, and bulk operations will surface here in Phase 5 once backend services solidify.
              </p>
              <div class="mt-8 grid gap-6 md:grid-cols-2">
                <div class="rounded-2xl border border-dashed border-white/10 p-6">
                  <p class="font-medium text-slate-300">Team Directory</p>
                  <p class="mt-3 text-sm text-slate-500">View and manage role-based access across the org.</p>
                </div>
                <div class="rounded-2xl border border-dashed border-white/10 p-6">
                  <p class="font-medium text-slate-300">Bulk Ops</p>
                  <p class="mt-3 text-sm text-slate-500">Upload CSVs/XLSX to seed large workstreams in a flash.</p>
                </div>
              </div>
            </div>
          </section>
        </div>
      </section>
    </main>

    <script>
      const server = new Proxy(
        {},
        {
          get(_, method) {
            return function (...args) {
              return new Promise((resolve, reject) => {
                const runnerRoot =
                  typeof google !== 'undefined' && google.script && typeof google.script.run !== 'undefined'
                    ? google.script.run
                    : null;
                if (!runnerRoot) {
                  console.warn(`[AuraFlow] google.script.run unavailable for method ${String(method)}`);
                  reject('Server unavailable. Please deploy as a Google Apps Script Web App.');
                  return;
                }
                const runner = runnerRoot
                  .withSuccessHandler((result) => {
                    if (result && typeof result === 'object' && 'success' in result) {
                      if (result.success) {
                        resolve(result.data);
                      } else {
                        reject(result.error || 'Unknown server error.');
                      }
                    } else {
                      resolve(result);
                    }
                  })
                  .withFailureHandler((err) => {
                    reject(err && err.message ? err.message : String(err || 'Request failed.'));
                  });
                if (typeof runner[method] !== 'function') {
                  reject(`Server method "${String(method)}" is not defined.`);
                  return;
                }
                try {
                  runner[method].apply(runner, args);
                } catch (invokeErr) {
                  reject(invokeErr && invokeErr.message ? invokeErr.message : String(invokeErr));
                }
              });
            };
          },
        }
      );

      (function () {
        const STORAGE_KEY = 'aura-flow-v2.session';
        const KANBAN_STATUSES = [
          { id: 'Planned', label: 'Planned' },
          { id: 'In-Progress', label: 'In-Progress' },
          { id: 'Completed', label: 'Completed' },
          { id: 'Shifted', label: 'Shifted' },
          { id: 'Cancelled', label: 'Cancelled' },
        ];
        const COLUMN_HIGHLIGHT_CLASSES = [
          'ring-2',
          'ring-aura-primary/60',
          'ring-offset-2',
          'ring-offset-slate-950'
        ];
        const state = {
          token: null,
          user: null,
          activeTab: 'dashboard',
          data: {
            tasks: [],
            moods: [],
            activity: [],
          },
          charts: {
            velocity: null,
            category: null,
            mood: null,
          },
          dataHydrated: false,
          activityHydrated: false,
        };
        const focusState = {
          durationMinutes: 25,
          remainingSeconds: 25 * 60,
          intervalId: null,
          isRunning: false,
          selectedTaskId: '',
          selectedMood: 'neutral',
          history: [],
        };
        const analyticsState = {
          isLoading: false,
          lastUpdated: null,
        };
        const dashboardState = {
          isActivityLoading: false,
          activityError: false,
          lastActivityFetchedAt: null,
        };
        const elements = {
          analytics: {},
          focus: {},
          dashboard: {},
        };

        const tabs = ['dashboard', 'kanban', 'analytics', 'focus', 'admin'];
        const STATUS_ORDER = {
          'In-Progress': 0,
          Planned: 1,
          Completed: 2,
          Shifted: 3,
          Cancelled: 4,
        };
        const CHART_PALETTE = ['#7f5af0', '#2cb1bc', '#f2a359', '#38bdf8', '#f472b6', '#22d3ee', '#f97316', '#94a3b8'];
        const MOOD_SCORES = {
          energized: 5,
          inspired: 5,
          excited: 5,
          motivated: 4,
          positive: 4,
          happy: 4,
          proud: 4,
          confident: 4,
          focused: 4,
          calm: 3,
          balanced: 3,
          neutral: 3,
          okay: 3,
          tired: 2,
          weary: 2,
          meh: 2,
          drained: 1,
          stressed: 1,
          overwhelmed: 1,
          anxious: 1,
          frustrated: 1,
          burnt: 1,
          burntout: 1,
        };
        let isInitialized = false;

        document.addEventListener('DOMContentLoaded', init);

        function init() {
          if (isInitialized) return;
          isInitialized = true;
          cacheElements();
          enhanceTabButtons();
          setupKanbanBoard();
          bindEvents();
          initializeFocusMode();
          updateShell();
          restoreSession();
        }

        function cacheElements() {
          elements.loginView = document.getElementById('loginView');
          elements.appView = document.getElementById('appView');
          elements.loginForm = document.getElementById('loginForm');
          elements.loginButton = document.getElementById('loginButton');
          elements.userBadge = document.getElementById('userBadge');
          elements.roleBadge = document.getElementById('roleBadge');
          elements.logoutButton = document.getElementById('logoutButton');
          elements.tabButtons = document.querySelectorAll('[data-tab-button]');
          elements.tabPanels = document.querySelectorAll('[data-tab-panel]');
          elements.analytics.refreshButton = document.getElementById('analyticsRefreshButton');
          elements.analytics.refreshTime = document.getElementById('analyticsRefreshTime');
          elements.analytics.velocityCanvas = document.getElementById('completionVelocityChart');
          elements.analytics.velocityEmpty = document.getElementById('velocityChartEmpty');
          elements.analytics.velocityMetric = document.getElementById('velocityMetric');
          elements.analytics.categoryCanvas = document.getElementById('timeByCategoryChart');
          elements.analytics.categoryEmpty = document.getElementById('categoryChartEmpty');
          elements.analytics.categoryMetric = document.getElementById('categoryMetric');
          elements.analytics.moodCanvas = document.getElementById('moodTrendChart');
          elements.analytics.moodEmpty = document.getElementById('moodChartEmpty');
          elements.analytics.moodMetric = document.getElementById('moodMetric');
          elements.focus.statusBadge = document.getElementById('focusStatusBadge');
          if (elements.focus.statusBadge) {
            elements.focus.statusDot = elements.focus.statusBadge.querySelector('[data-role="focus-status-dot"]');
            elements.focus.statusText = elements.focus.statusBadge.querySelector('[data-role="focus-status-text"]');
          }
          elements.focus.timerDisplay = document.getElementById('focusTimerDisplay');
          elements.focus.timerSubtitle = document.getElementById('focusTimerSubtitle');
          elements.focus.startButton = document.getElementById('focusStartButton');
          elements.focus.pauseButton = document.getElementById('focusPauseButton');
          elements.focus.resetButton = document.getElementById('focusResetButton');
          elements.focus.durationInput = document.getElementById('focusDurationInput');
          elements.focus.taskSelect = document.getElementById('focusTaskSelect');
          elements.focus.moodSelect = document.getElementById('focusMoodSelect');
          elements.focus.historyList = document.getElementById('focusHistoryList');
          elements.focus.historyEmpty = document.getElementById('focusHistoryEmpty');
          elements.focus.clearHistoryButton = document.getElementById('focusClearHistoryButton');

          elements.dashboard.metrics = {
            today: document.getElementById('metric-today'),
            todayContext: document.getElementById('metric-today-context'),
            todayDetail: document.getElementById('metric-today-detail'),
            completed: document.getElementById('metric-complete'),
            completedContext: document.getElementById('metric-complete-context'),
            completedDetail: document.getElementById('metric-complete-detail'),
            time: document.getElementById('metric-time'),
            timeContext: document.getElementById('metric-time-context'),
            timeDetail: document.getElementById('metric-time-detail'),
            overdue: document.getElementById('metric-overdue'),
            overdueContext: document.getElementById('metric-overdue-context'),
            overdueDetail: document.getElementById('metric-overdue-detail'),
          };
          elements.dashboard.activityList = document.getElementById('activityList');
          elements.dashboard.activityEmpty = document.getElementById('activityEmpty');
          elements.dashboard.activityLoading = document.getElementById('activityLoading');
          elements.dashboard.activityTimestamp = document.getElementById('activityTimestamp');

        }

        function enhanceTabButtons() {
          elements.tabButtons.forEach((btn) => {

            btn.classList.add(
              'whitespace-nowrap',
              'rounded-full',
              'px-4',
              'py-2',
              'text-sm',
              'font-medium',
              'text-slate-300',
              'transition',
              'bg-white/0',
              'hover:bg-white/10',
              'focus-visible:outline',
              'focus-visible:outline-2',
              'focus-visible:outline-offset-2',
              'focus-visible:outline-white/40'
            );
            btn.setAttribute('role', 'tab');
          });
          elements.tabPanels.forEach((panel) => {
            panel.setAttribute('role', 'tabpanel');
            panel.setAttribute('aria-hidden', panel.classList.contains('hidden') ? 'true' : 'false');
          });
        }

        function setupKanbanBoard() {
          if (!elements.kanbanBoard) {
            return;
          }
          KANBAN_STATUSES.forEach((status) => {
            const column = elements.kanbanColumns[status.id];
            if (!column) {
              return;
            }
            column.addEventListener('dragenter', (event) => handleKanbanDragEnter(event, status.id));
            column.addEventListener('dragover', (event) => handleKanbanDragOver(event, status.id));
            column.addEventListener('dragleave', (event) => handleKanbanDragLeave(event, status.id));
            column.addEventListener('drop', (event) => handleKanbanDrop(event, status.id));
          });
          renderKanbanBoard();
        }

        function bindEvents() {
          if (elements.loginForm) {
            elements.loginForm.addEventListener('submit', handleLoginSubmit, { once: false });
          }
          if (elements.logoutButton) {
            elements.logoutButton.addEventListener('click', handleLogout, { once: false });
          }
          elements.tabButtons.forEach((btn) => {
            btn.addEventListener('click', () => {
              const targetTab = btn.getAttribute('data-tab-button');
              setActiveTab(targetTab);
            });
          });
          if (elements.analytics.refreshButton) {
            elements.analytics.refreshButton.addEventListener('click', () => refreshWorkspaceData({ silent: false }));
          }
          if (elements.focus.startButton) {
            elements.focus.startButton.addEventListener('click', startFocusTimer);
          }
          if (elements.focus.pauseButton) {
            elements.focus.pauseButton.addEventListener('click', pauseFocusTimer);
          }
          if (elements.focus.resetButton) {
            elements.focus.resetButton.addEventListener('click', resetFocusTimer);
          }
          if (elements.focus.durationInput) {
            elements.focus.durationInput.addEventListener('change', handleFocusDurationChange);
          }
          if (elements.focus.taskSelect) {
            elements.focus.taskSelect.addEventListener('change', handleFocusTaskChange);
          }
          if (elements.focus.moodSelect) {
            elements.focus.moodSelect.addEventListener('change', handleFocusMoodChange);
          }
          if (elements.focus.clearHistoryButton) {
            elements.focus.clearHistoryButton.addEventListener('click', clearFocusHistory);
          }
        }

        async function handleLoginSubmit(event) {
          event.preventDefault();
          const formData = new FormData(elements.loginForm);
          const email = String(formData.get('email') || '').trim();
          const password = String(formData.get('password') || '');
          if (!email || !password) {
            showToast('Please provide both email and password.', 'error');
            return;
          }
          setButtonLoading(elements.loginButton, true);
          try {
            const response = await server.login(email, password);
            if (!response || !response.token) {
              throw new Error('Unexpected response from server.');
            }
            applySession(response.token, response.user);
            persistSession(response.token, response.user);
            showToast(`Welcome back, ${response.user.Email}!`, 'success');
          } catch (err) {
            console.error('Login failed:', err);
            showToast(err && err.message ? err.message : String(err), 'error');
          } finally {
            setButtonLoading(elements.loginButton, false);
          }
        }

        async function handleLogout() {
          const currentToken = state.token;
          clearSession();
          updateShell();
          if (currentToken) {
            try {
              await server.logout(currentToken);
            } catch (err) {
              console.warn('Logout warning:', err);
            }
          }
          showToast('You are signed out.', 'success');
        }

        function setButtonLoading(button, isLoading) {
          if (!button) return;
          button.disabled = isLoading;
          button.classList.toggle('opacity-70', isLoading);
          button.setAttribute('aria-busy', isLoading ? 'true' : 'false');
          const spinner = button.querySelector('[data-role="spinner"]');
          const label = button.querySelector('[data-role="label"]');
          if (spinner) spinner.classList.toggle('hidden', !isLoading);
          if (label) label.classList.toggle('opacity-0', isLoading);
        }

        function setActiveTab(tabId) {
          if (!tabs.includes(tabId)) {
            return;
          }
          state.activeTab = tabId;
          elements.tabButtons.forEach((btn) => {
            const isActive = btn.getAttribute('data-tab-button') === tabId;
            btn.classList.toggle('bg-white/10', isActive);
            btn.classList.toggle('text-white', isActive);
            btn.classList.toggle('text-slate-300', !isActive);
            btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
            btn.setAttribute('tabindex', isActive ? '0' : '-1');
          });
          elements.tabPanels.forEach((panel) => {
            const isActive = panel.getAttribute('data-tab-panel') === tabId;
            panel.classList.toggle('hidden', !isActive);
            panel.setAttribute('aria-hidden', isActive ? 'false' : 'true');
          });
          if (tabId === 'analytics') {
            renderAnalyticsCharts();
            requestAnimationFrame(() => {
              Object.values(state.charts).forEach((chart) => {
                if (chart && typeof chart.resize === 'function') {
                  chart.resize();
                }
              });
            });
          }
          if (tabId === 'focus') {
            updateFocusControls();

          }
        }

        function applySession(token, user) {
          state.token = token;
          state.user = user || null;
          updateShell();
          refreshWorkspaceData({ silent: true });

        }

        function updateShell() {
          const isAuthenticated = Boolean(state.token && state.user);
          if (elements.loginView) {
            elements.loginView.classList.toggle('hidden', isAuthenticated);
          }
          if (elements.appView) {
            elements.appView.classList.toggle('hidden', !isAuthenticated);
          }
          if (elements.userBadge) {
            elements.userBadge.textContent = isAuthenticated ? state.user.Email : 'Not authenticated';
          }
          if (elements.roleBadge) {
            elements.roleBadge.textContent = isAuthenticated && state.user.Role ? state.user.Role : '';
          }
          renderKanbanBoard();
          updateDashboardMetrics();
          renderActivitySnapshot();
          setActiveTab(state.activeTab);
        }

        function persistSession(token, user) {
          try {
            const payload = JSON.stringify({ token, user });
            localStorage.setItem(STORAGE_KEY, payload);
          } catch (err) {
            console.warn('Failed to persist session', err);
          }
        }

        function clearSession() {
          state.token = null;
          state.user = null;
          resetWorkspaceData();
          try {
            localStorage.removeItem(STORAGE_KEY);
          } catch (err) {
            console.warn('Failed to clear session storage', err);
          }
          resetKanbanState();
        }

        async function restoreSession() {
          let stored = null;
          try {
            const raw = localStorage.getItem(STORAGE_KEY);
            if (raw) {
              stored = JSON.parse(raw);
            }
          } catch (err) {
            console.warn('Failed to parse stored session', err);
          }
          if (!stored || !stored.token) {
            updateShell();
            return;
          }
          try {
            const sessionInfo = await server.whoami(stored.token);
            if (sessionInfo && sessionInfo.token && sessionInfo.user) {
              persistSession(sessionInfo.token, sessionInfo.user);
              applySession(sessionInfo.token, sessionInfo.user);
              showToast(`Welcome back, ${sessionInfo.user.Email}!`, 'success');
              return;
            }
            throw new Error('Session invalid.');
          } catch (err) {
            console.warn('Session restore failed:', err);
            clearSession();
            updateShell();
          }
        }

        async function refreshWorkspaceData(options = {}) {
          const { silent = false } = options;
          if (!state.token) {
            resetWorkspaceData();
            return;
          }
          if (analyticsState.isLoading) {
            return;
          }
          analyticsState.isLoading = true;
          if (elements.analytics.refreshButton && !silent) {
            setButtonLoading(elements.analytics.refreshButton, true);
          }
          try {
            const [tasks, moods] = await Promise.all([
              server.listTasks(state.token, {}),
              server.listMoods(state.token, {}),
            ]);
            state.data.tasks = Array.isArray(tasks) ? tasks : [];
            state.data.moods = Array.isArray(moods) ? moods : [];
            state.dataHydrated = true;
            analyticsState.lastUpdated = new Date();
            updateAnalyticsTimestamp();
            populateFocusTaskSelect();
            renderAnalyticsCharts();
            updateDashboardMetrics();
            refreshActivityLog({ silent: true });
          } catch (err) {
            console.error('Failed to refresh workspace data:', err);
            showToast(err && err.message ? err.message : 'Unable to refresh analytics.', 'error');
            renderAnalyticsCharts();
            if (!state.dataHydrated) {
              state.data.tasks = [];
              state.data.moods = [];
            }
            updateDashboardMetrics();
          } finally {
            analyticsState.isLoading = false;
            if (elements.analytics.refreshButton && !silent) {
              setButtonLoading(elements.analytics.refreshButton, false);
            }
          }
        }

        async function refreshActivityLog(options = {}) {
          const { silent = false, limit = 10 } = options;
          if (!state.token) {
            state.data.activity = [];
            state.activityHydrated = false;
            dashboardState.isActivityLoading = false;
            dashboardState.activityError = false;
            dashboardState.lastActivityFetchedAt = null;
            renderActivitySnapshot();
            return;
          }
          dashboardState.isActivityLoading = true;
          dashboardState.activityError = false;
          renderActivitySnapshot();
          try {
            const entries = await server.listActivityLog(state.token, { limit });
            state.data.activity = Array.isArray(entries) ? entries : [];
            state.activityHydrated = true;
            dashboardState.lastActivityFetchedAt = new Date();
          } catch (err) {
            console.warn('Failed to load activity log:', err);
            dashboardState.activityError = true;
            if (!silent) {
              showToast(err && err.message ? err.message : 'Unable to load activity log.', 'error');
            }
            if (!state.activityHydrated) {
              state.data.activity = [];
            }
          } finally {
            dashboardState.isActivityLoading = false;
            renderActivitySnapshot();
          }
        }

        function updateDashboardMetrics() {
          const metrics = elements.dashboard.metrics || {};
          if (!metrics.today || !metrics.completed || !metrics.time || !metrics.overdue) {
            return;
          }
          if (!state.dataHydrated) {
            setMetricOutput(metrics.today, null);
            setTextContent(metrics.todayContext, '—');
            setMetricDetail(metrics.todayDetail, 'Awaiting workspace sync.');
            setMetricOutput(metrics.completed, null);
            setTextContent(metrics.completedContext, '—');
            setMetricDetail(metrics.completedDetail, 'Awaiting workspace sync.');
            setMetricOutput(metrics.time, null, { isTime: true });
            setTextContent(metrics.timeContext, '—');
            setMetricDetail(metrics.timeDetail, 'Awaiting workspace sync.');
            setMetricOutput(metrics.overdue, null);
            setTextContent(metrics.overdueContext, '—');
            setMetricDetail(metrics.overdueDetail, 'Awaiting workspace sync.');
            return;
          }

          const tasks = Array.isArray(state.data.tasks) ? state.data.tasks : [];
          const totalTasks = tasks.length;
          const todayKey = formatDateKey(new Date());
          let tasksToday = 0;
          let completedCount = 0;
          let latestCompletedAt = null;
          let timeMinutes = 0;
          let tasksWithDuration = 0;
          let overdueCount = 0;
          let oldestOverdueDate = null;
          let openCount = 0;

          tasks.forEach((task) => {
            if (!task) return;
            const status = String(task.Status || '').trim();
            const dueKey = formatDateKey(task.DueAt || '');
            if (dueKey && dueKey === todayKey) {
              tasksToday += 1;
            }
            if (status === 'Completed') {
              completedCount += 1;
              const completedAt = parseDate(task.UpdatedAt || task.Timestamp || task.DueAt);
              if (completedAt && (!latestCompletedAt || completedAt > latestCompletedAt)) {
                latestCompletedAt = completedAt;
              }
            } else {
              openCount += 1;
            }
            const duration = Number(task.DurationMins || 0);
            if (duration > 0) {
              timeMinutes += duration;
              tasksWithDuration += 1;
            }
            if (status !== 'Completed' && dueKey && dueKey < todayKey) {
              overdueCount += 1;
              const dueDate = parseDateKeyString(dueKey);
              if (dueDate && (!oldestOverdueDate || dueDate < oldestOverdueDate)) {
                oldestOverdueDate = dueDate;
              }
            }
          });

          const completedPercent = totalTasks > 0 ? Math.round((completedCount / totalTasks) * 100) : 0;
          const overduePercent = openCount > 0 ? Math.round((overdueCount / openCount) * 100) : 0;

          setMetricOutput(metrics.today, tasksToday);
          setTextContent(metrics.todayContext, totalTasks ? `${totalTasks} total` : '0 total');
          const todayDetail = totalTasks
            ? `Tasks due ${formatDisplayFullDate(todayKey)}`
            : 'No tracked tasks yet.';
          setMetricDetail(metrics.todayDetail, todayDetail);

          setMetricOutput(metrics.completed, completedCount);
          setTextContent(
            metrics.completedContext,
            totalTasks ? `${completedPercent}% done` : '—'
          );
          const completedDetail = completedCount && latestCompletedAt
            ? `Latest completion ${formatRelativeTime(latestCompletedAt)}.`
            : 'No completed tasks yet.';
          setMetricDetail(metrics.completedDetail, completedDetail);

          setMetricOutput(metrics.time, timeMinutes, { isTime: true });
          setTextContent(
            metrics.timeContext,
            tasksWithDuration ? `${tasksWithDuration} tasks` : 'No estimates'
          );
          const timeDetail = timeMinutes
            ? `Total tracked ${formatMinutes(timeMinutes)}.`
            : 'Add duration estimates to track time.';
          setMetricDetail(metrics.timeDetail, timeDetail);

          setMetricOutput(metrics.overdue, overdueCount);
          setTextContent(
            metrics.overdueContext,
            openCount ? `${overduePercent}% of open` : 'No open tasks'
          );
          let overdueDetail = 'All clear — stay on track.';
          if (overdueCount > 0 && oldestOverdueDate) {
            const days = Math.max(1, calculateDayDelta(oldestOverdueDate, new Date()));
            overdueDetail = `Oldest overdue ${days} ${days === 1 ? 'day' : 'days'} ago.`;
          } else if (overdueCount > 0) {
            overdueDetail = 'Overdue tasks detected — review priorities.';
          }
          setMetricDetail(metrics.overdueDetail, overdueDetail);
        }

        function renderActivitySnapshot() {
          const list = elements.dashboard.activityList;
          if (!list) {
            return;
          }
          const empty = elements.dashboard.activityEmpty;
          const loading = elements.dashboard.activityLoading;
          const timestamp = elements.dashboard.activityTimestamp;
          const isLoading = dashboardState.isActivityLoading;
          const hasError = dashboardState.activityError;
          const isHydrated = state.activityHydrated;

          if (loading) {
            loading.classList.toggle('hidden', !isLoading);
            loading.classList.toggle('flex', isLoading);
          }

          list.innerHTML = '';

          if (timestamp) {
            if (dashboardState.lastActivityFetchedAt) {
              const formatted = dashboardState.lastActivityFetchedAt.toLocaleString(undefined, {
                hour: '2-digit',
                minute: '2-digit',
                month: 'short',
                day: 'numeric',
              });
              timestamp.textContent = `Updated ${formatted}`;
            } else {
              timestamp.textContent = '—';
            }
          }

          if (isLoading) {
            if (empty) {
              empty.classList.add('hidden');
            }
            return;
          }

          if (hasError) {
            if (empty) {
              empty.textContent = 'Activity feed unavailable';
              empty.classList.remove('hidden');
            }
            return;
          }

          const entries = Array.isArray(state.data.activity) ? state.data.activity.slice(0, 10) : [];

          if (entries.length === 0) {
            if (empty) {
              if (isHydrated) {
                empty.textContent = 'No recent activity';
              } else {
                empty.textContent = '—';
              }
              empty.classList.remove('hidden');
            }
            return;
          }

          const fragment = document.createDocumentFragment();
          entries.forEach((entry) => {
            fragment.appendChild(createActivityListItem(entry));
          });
          list.appendChild(fragment);
          if (empty) {
            empty.classList.add('hidden');
          }
        }

        function createActivityListItem(entry) {
          const item = document.createElement('li');
          item.className = 'flex items-start justify-between gap-4 rounded-2xl border border-white/5 bg-slate-950/60 p-4';

          const left = document.createElement('div');
          left.className = 'space-y-1';

          const actor = document.createElement('p');
          actor.className = 'text-sm font-semibold text-white';
          actor.textContent = formatActorLabel(entry && (entry.ActorEmail || entry.actorEmail || entry.actor));
          left.appendChild(actor);

          const action = document.createElement('p');
          action.className = 'text-sm text-slate-300';
          action.textContent = formatActivityAction(entry && (entry.Action || entry.action));
          left.appendChild(action);

          const target = document.createElement('p');
          target.className = 'text-xs text-slate-500';
          target.textContent = formatActivityTarget(entry && (entry.TargetType || entry.targetType), entry && (entry.TargetID || entry.targetId));
          left.appendChild(target);

          const right = document.createElement('div');
          right.className = 'flex flex-col items-end gap-1 text-xs text-slate-400';

          const relative = document.createElement('p');
          relative.textContent = formatRelativeTime(entry && (entry.At || entry.at));
          right.appendChild(relative);

          const absolute = document.createElement('p');
          absolute.className = 'text-[0.65rem] text-slate-500';
          absolute.textContent = formatDateTime(entry && (entry.At || entry.at));
          right.appendChild(absolute);

          item.append(left, right);
          return item;
        }

        function updateAnalyticsTimestamp() {
          if (!elements.analytics.refreshTime) return;
          if (!analyticsState.lastUpdated) {
            elements.analytics.refreshTime.textContent = 'Awaiting data…';
            return;
          }
          const formatted = analyticsState.lastUpdated.toLocaleString(undefined, {
            hour: '2-digit',
            minute: '2-digit',
            month: 'short',
            day: 'numeric',
          });
          elements.analytics.refreshTime.textContent = `Updated ${formatted}`;
        }

        function renderAnalyticsCharts() {
          updateCompletionVelocityChart();
          updateTimeByCategoryChart();
          updateMoodTrendChart();
        }

        function updateCompletionVelocityChart() {
          const canvas = elements.analytics.velocityCanvas;
          const emptyState = elements.analytics.velocityEmpty;
          const metric = elements.analytics.velocityMetric;
          if (!canvas) return;
          const windowDays = 14;
          const now = new Date();
          now.setHours(0, 0, 0, 0);
          const dayKeys = [];
          for (let offset = windowDays - 1; offset >= 0; offset--) {
            const day = new Date(now);
            day.setDate(now.getDate() - offset);
            dayKeys.push(formatDateKey(day));
          }
          const completions = new Map();
          const tasks = Array.isArray(state.data.tasks) ? state.data.tasks : [];
          tasks.forEach((task) => {
            if (!task || task.Status !== 'Completed') return;
            const key = formatDateKey(task.UpdatedAt || task.Timestamp);
            if (!key) return;
            completions.set(key, (completions.get(key) || 0) + 1);
          });
          const values = dayKeys.map((key) => completions.get(key) || 0);
          const labels = dayKeys.map((key) => formatDisplayDate(key));
          const totalCompleted = values.reduce((sum, value) => sum + value, 0);
          if (metric) {
            metric.textContent = totalCompleted ? `${totalCompleted} / ${windowDays} days` : '—';
          }
          const hasData = totalCompleted > 0;
          toggleEmptyState(emptyState, !hasData);
          if (!hasData) {
            destroyChart('velocity');
            return;
          }
          const config = {
            type: 'line',
            data: {
              labels,
              datasets: [
                {
                  label: 'Tasks completed',
                  data: values,
                  borderColor: '#7f5af0',
                  backgroundColor: 'rgba(127, 90, 240, 0.25)',
                  borderWidth: 2,
                  tension: 0.35,
                  fill: true,
                  pointRadius: 3,
                  pointBackgroundColor: '#7f5af0',
                },
              ],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    label(context) {
                      return `${context.parsed.y} completed`;
                    },
                  },
                },
              },
              scales: {
                y: {
                  beginAtZero: true,
                  ticks: { precision: 0 },
                  grid: { color: 'rgba(148, 163, 184, 0.12)' },
                },
                x: {
                  grid: { display: false },
                },
              },
            },
          };
          applyChartInstance('velocity', canvas, config);
        }

        function updateTimeByCategoryChart() {
          const canvas = elements.analytics.categoryCanvas;
          const emptyState = elements.analytics.categoryEmpty;
          const metric = elements.analytics.categoryMetric;
          if (!canvas) return;
          const categoryTotals = new Map();
          const tasks = Array.isArray(state.data.tasks) ? state.data.tasks : [];
          tasks.forEach((task) => {
            if (!task) return;
            const category = String(task.Category || '').trim() || 'Uncategorized';
            const minutes = Number(task.DurationMins || 0);
            if (!minutes) return;
            categoryTotals.set(category, (categoryTotals.get(category) || 0) + minutes);
          });
          const sorted = Array.from(categoryTotals.entries()).sort((a, b) => b[1] - a[1]);
          const labels = sorted.map(([category]) => category);
          const values = sorted.map(([, minutes]) => minutes);
          const totalMinutes = values.reduce((sum, value) => sum + value, 0);
          if (metric) {
            metric.textContent = totalMinutes ? formatMinutes(totalMinutes) : '—';
          }
          const hasData = values.length > 0;
          toggleEmptyState(emptyState, !hasData);
          if (!hasData) {
            destroyChart('category');
            return;
          }
          const colors = labels.map((_, index) => CHART_PALETTE[index % CHART_PALETTE.length]);
          const config = {
            type: 'doughnut',
            data: {
              labels,
              datasets: [
                {
                  label: 'Minutes',
                  data: values,
                  backgroundColor: colors,
                  borderWidth: 0,
                },
              ],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  display: true,
                  position: 'bottom',
                  labels: { color: '#cbd5f5' },
                },
                tooltip: {
                  callbacks: {
                    label(context) {
                      const value = context.parsed;
                      return `${context.label}: ${formatMinutes(value)}`;
                    },
                  },
                },
              },
              cutout: '58%',
            },
          };
          applyChartInstance('category', canvas, config);
        }

        function updateMoodTrendChart() {
          const canvas = elements.analytics.moodCanvas;
          const emptyState = elements.analytics.moodEmpty;
          const metric = elements.analytics.moodMetric;
          if (!canvas) return;
          const entries = Array.isArray(state.data.moods) ? state.data.moods : [];
          const dayBuckets = new Map();
          entries.forEach((entry) => {
            if (!entry) return;
            const key = formatDateKey(entry.At);
            if (!key) return;
            const score = resolveMoodScore(entry.Mood);
            const bucket = dayBuckets.get(key) || { total: 0, count: 0 };
            bucket.total += score;
            bucket.count += 1;
            dayBuckets.set(key, bucket);
          });
          const sortedKeys = Array.from(dayBuckets.keys()).sort();
          const labels = sortedKeys.map((key) => formatDisplayDate(key));
          const values = sortedKeys.map((key) => {
            const bucket = dayBuckets.get(key);
            if (!bucket || !bucket.count) return 0;
            return Number((bucket.total / bucket.count).toFixed(2));
          });
          const hasData = values.length > 0;
          if (metric) {
            metric.textContent = hasData ? `${values[values.length - 1].toFixed(1)} / 5` : '—';
          }
          toggleEmptyState(emptyState, !hasData);
          if (!hasData) {
            destroyChart('mood');
            return;
          }
          const config = {
            type: 'line',
            data: {
              labels,
              datasets: [
                {
                  label: 'Average mood',
                  data: values,
                  borderColor: '#2cb1bc',
                  backgroundColor: 'rgba(44, 177, 188, 0.25)',
                  borderWidth: 2,
                  tension: 0.35,
                  fill: true,
                  pointRadius: 3,
                  pointBackgroundColor: '#2cb1bc',
                },
              ],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                y: {
                  suggestedMin: 1,
                  suggestedMax: 5,
                  ticks: { stepSize: 1 },
                  grid: { color: 'rgba(148, 163, 184, 0.12)' },
                },
                x: {
                  grid: { display: false },
                },
              },
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    label(context) {
                      return `Mood score: ${context.parsed.y.toFixed(2)}`;
                    },
                  },
                },
              },
            },
          };
          applyChartInstance('mood', canvas, config);
        }

        function applyChartInstance(key, canvas, config) {
          if (!canvas) return;
          const existing = state.charts[key];
          if (existing) {
            existing.data = config.data;
            existing.options = config.options;
            existing.update();
            return;
          }
          const ctx = canvas.getContext('2d');
          state.charts[key] = new Chart(ctx, config);
        }

        function destroyChart(key) {
          const chart = state.charts[key];
          if (chart && typeof chart.destroy === 'function') {
            chart.destroy();
          }
          state.charts[key] = null;
        }

        function populateFocusTaskSelect() {
          const select = elements.focus.taskSelect;
          if (!select) return;
          const currentValue = focusState.selectedTaskId || select.value || '';
          while (select.options.length > 1) {
            select.remove(1);
          }
          const tasks = Array.isArray(state.data.tasks) ? state.data.tasks.slice() : [];
          tasks.sort((a, b) => {
            const aScore = STATUS_ORDER[a.Status] ?? 99;
            const bScore = STATUS_ORDER[b.Status] ?? 99;
            if (aScore === bScore) {
              return (a.Name || '').localeCompare(b.Name || '');
            }
            return aScore - bScore;
          });
          tasks.forEach((task) => {
            const option = document.createElement('option');
            option.value = task.TaskID;
            const statusBadge = task.Status && task.Status !== 'Completed' ? ` • ${task.Status}` : '';
            option.textContent = `${task.Name || task.TaskID}${statusBadge}`;
            select.appendChild(option);
          });
          if (currentValue && tasks.some((task) => task.TaskID === currentValue)) {
            select.value = currentValue;
            focusState.selectedTaskId = currentValue;
          } else {
            select.value = '';
            focusState.selectedTaskId = '';
          }
          updateFocusControls();
        }

        function initializeFocusMode() {
          if (elements.focus.durationInput) {
            const initial = Number(elements.focus.durationInput.value) || 25;
            focusState.durationMinutes = clampNumber(initial, 5, 90);
            elements.focus.durationInput.value = focusState.durationMinutes;
          }
          focusState.remainingSeconds = focusState.durationMinutes * 60;
          focusState.selectedTaskId = elements.focus.taskSelect ? elements.focus.taskSelect.value || '' : '';
          focusState.selectedMood = elements.focus.moodSelect ? elements.focus.moodSelect.value || 'neutral' : 'neutral';
          focusState.history = [];
          updateFocusTimerDisplay();
          updateFocusSubtitle();
          updateFocusStatus('ready');
          updateFocusControls();
          updateFocusHistoryUi();
        }

        function startFocusTimer() {
          if (!state.token) {
            showToast('Sign in to start a focus session.', 'error');
            return;
          }
          if (!focusState.selectedTaskId) {
            showToast('Select a task to anchor your session.', 'error');
            return;
          }
          if (focusState.isRunning) {
            return;
          }
          if (focusState.remainingSeconds <= 0) {
            focusState.remainingSeconds = focusState.durationMinutes * 60;
          }
          focusState.isRunning = true;
          focusState.intervalId = window.setInterval(handleFocusTick, 1000);
          updateFocusStatus('running');
          updateFocusControls();
          updateFocusSubtitle();
        }

        function pauseFocusTimer() {
          if (!focusState.isRunning) {
            return;
          }
          focusState.isRunning = false;
          if (focusState.intervalId) {
            clearInterval(focusState.intervalId);
            focusState.intervalId = null;
          }
          updateFocusStatus('paused');
          updateFocusControls();
          updateFocusSubtitle();
        }

        function resetFocusTimer() {
          if (focusState.intervalId) {
            clearInterval(focusState.intervalId);
            focusState.intervalId = null;
          }
          focusState.isRunning = false;
          focusState.remainingSeconds = focusState.durationMinutes * 60;
          updateFocusTimerDisplay();
          updateFocusStatus('ready');
          updateFocusControls();
          updateFocusSubtitle();
        }

        function handleFocusDurationChange(event) {
          const value = Number(event.target.value);
          if (!Number.isFinite(value)) {
            event.target.value = focusState.durationMinutes;
            return;
          }
          focusState.durationMinutes = clampNumber(Math.round(value), 5, 90);
          event.target.value = focusState.durationMinutes;
          if (!focusState.isRunning) {
            focusState.remainingSeconds = focusState.durationMinutes * 60;
            updateFocusTimerDisplay();
            updateFocusSubtitle();
          }
        }

        function handleFocusTaskChange(event) {
          focusState.selectedTaskId = event.target.value || '';
          updateFocusControls();
        }

        function handleFocusMoodChange(event) {
          focusState.selectedMood = event.target.value || 'neutral';
        }

        function handleFocusTick() {
          if (!focusState.isRunning) {
            return;
          }
          focusState.remainingSeconds = Math.max(0, focusState.remainingSeconds - 1);
          updateFocusTimerDisplay();
          if (focusState.remainingSeconds <= 0) {
            handleFocusSessionComplete();
          }
        }

        async function handleFocusSessionComplete() {
          if (focusState.intervalId) {
            clearInterval(focusState.intervalId);
            focusState.intervalId = null;
          }
          focusState.isRunning = false;
          focusState.remainingSeconds = 0;
          updateFocusTimerDisplay();
          updateFocusStatus('completed');
          updateFocusControls();
          updateFocusSubtitle();

          const taskId = focusState.selectedTaskId;
          const mood = focusState.selectedMood || 'neutral';
          const taskName = getTaskNameById(taskId) || taskId || 'Focus session';
          const duration = focusState.durationMinutes;
          focusState.history.unshift({
            id: String(Date.now()),
            taskId,
            taskName,
            mood,
            duration,
            completedAt: new Date(),
          });
          focusState.history = focusState.history.slice(0, 6);
          updateFocusHistoryUi();

          if (!state.token || !taskId) {
            showToast('Session complete — assign a task to sync analytics next time.', 'info');
            focusState.remainingSeconds = focusState.durationMinutes * 60;
            updateFocusTimerDisplay();
            updateFocusStatus('ready');
            updateFocusControls();
            updateFocusSubtitle();
            return;
          }

          const note = `Focus session (${duration} min) completed via Aura Flow Focus Mode.`;
          const logPromises = [
            server.logMood(state.token, taskId, mood, note),
          ];
          if (state.user && state.user.Email) {
            logPromises.push(
              server.logActivity_(state.user.Email, 'focus.session.complete', 'Task', taskId, {
                durationMinutes: duration,
                mood,
              })
            );
          }

          const results = await Promise.allSettled(logPromises);
          const failed = results.find((result) => result.status === 'rejected');
          if (failed) {
            const reason = failed.reason && failed.reason.message ? failed.reason.message : String(failed.reason || 'Unable to record focus session.');
            showToast(reason, 'error');
          } else {
            showToast('Focus session captured. Mood & activity logged.', 'success');
          }
          focusState.remainingSeconds = focusState.durationMinutes * 60;
          updateFocusTimerDisplay();
          updateFocusStatus('ready');
          updateFocusControls();
          updateFocusSubtitle();
          refreshWorkspaceData({ silent: true });
        }

        function clearFocusHistory() {
          focusState.history = [];
          updateFocusHistoryUi();
          showToast('Focus session history cleared.', 'success');
        }

        function updateFocusHistoryUi() {
          const list = elements.focus.historyList;
          const empty = elements.focus.historyEmpty;
          if (!list || !empty) return;
          if (!focusState.history.length) {
            empty.classList.remove('hidden');
            list.classList.add('hidden');
            list.innerHTML = '';
            return;
          }
          empty.classList.add('hidden');
          list.classList.remove('hidden');
          list.innerHTML = focusState.history
            .map((entry) => {
              const moodLabel = entry.mood ? entry.mood.charAt(0).toUpperCase() + entry.mood.slice(1) : 'Neutral';
              return `<li class="rounded-2xl border border-white/10 bg-slate-950/40 p-4">
                <div class="flex flex-wrap items-center justify-between gap-3">
                  <p class="font-medium text-slate-100">${escapeHtml(entry.taskName)}</p>
                  <span class="rounded-full bg-white/10 px-2.5 py-1 text-xs font-medium text-slate-300">${escapeHtml(moodLabel)}</span>
                </div>
                <p class="mt-2 text-xs text-slate-500">${escapeHtml(formatHistoryTimestamp(entry.completedAt))} • ${entry.duration} min</p>
              </li>`;
            })
            .join('');
        }

        function updateFocusTimerDisplay() {
          if (!elements.focus.timerDisplay) return;
          const totalSeconds = Math.max(0, Math.round(focusState.remainingSeconds));
          const minutes = String(Math.floor(totalSeconds / 60)).padStart(2, '0');
          const seconds = String(totalSeconds % 60).padStart(2, '0');
          elements.focus.timerDisplay.textContent = `${minutes}:${seconds}`;
        }

        function updateFocusSubtitle() {
          if (!elements.focus.timerSubtitle) return;
          if (focusState.isRunning) {
            elements.focus.timerSubtitle.textContent = 'Focus in progress — stay in flow until the timer completes.';
            return;
          }
          const defaultSeconds = focusState.durationMinutes * 60;
          if (focusState.remainingSeconds !== defaultSeconds && focusState.remainingSeconds > 0) {
            const minutesLeft = Math.ceil(focusState.remainingSeconds / 60);
            elements.focus.timerSubtitle.textContent = `Paused with ${minutesLeft} minute${minutesLeft === 1 ? '' : 's'} remaining.`;
            return;
          }
          elements.focus.timerSubtitle.textContent = `Default Pomodoro — ${focusState.durationMinutes} minutes`;
        }

        function updateFocusStatus(status) {
          const badge = elements.focus.statusBadge;
          if (!badge) return;
          const dot = elements.focus.statusDot;
          const text = elements.focus.statusText;
          const palette = {
            ready: 'bg-emerald-400/70',
            running: 'bg-emerald-400',
            paused: 'bg-amber-400',
            completed: 'bg-sky-400',
          };
          const label = {
            ready: 'Ready',
            running: 'In progress',
            paused: 'Paused',
            completed: 'Completed',
          };
          if (dot) {
            dot.className = `h-2.5 w-2.5 rounded-full ${palette[status] || palette.ready}`;
          }
          if (text) {
            text.textContent = label[status] || label.ready;
          }
        }

        function updateFocusControls() {
          const startButton = elements.focus.startButton;
          const pauseButton = elements.focus.pauseButton;
          const resetButton = elements.focus.resetButton;
          if (startButton) {
            const disabled = focusState.isRunning || !state.token || !focusState.selectedTaskId;
            startButton.disabled = disabled;
            startButton.classList.toggle('opacity-60', disabled);
          }
          if (pauseButton) {
            const disabled = !focusState.isRunning;
            pauseButton.disabled = disabled;
            pauseButton.classList.toggle('opacity-60', disabled);
          }
          if (resetButton) {
            resetButton.disabled = false;
          }
        }

        function resetWorkspaceData() {
          state.data.tasks = [];
          state.data.moods = [];
          state.data.activity = [];
          state.dataHydrated = false;
          state.activityHydrated = false;
          dashboardState.isActivityLoading = false;
          dashboardState.activityError = false;
          dashboardState.lastActivityFetchedAt = null;
          analyticsState.lastUpdated = null;
          updateAnalyticsTimestamp();
          destroyChart('velocity');
          destroyChart('category');
          destroyChart('mood');
          toggleEmptyState(elements.analytics.velocityEmpty, true);
          toggleEmptyState(elements.analytics.categoryEmpty, true);
          toggleEmptyState(elements.analytics.moodEmpty, true);
          if (elements.analytics.velocityMetric) {
            elements.analytics.velocityMetric.textContent = '—';
          }
          if (elements.analytics.categoryMetric) {
            elements.analytics.categoryMetric.textContent = '—';
          }
          if (elements.analytics.moodMetric) {
            elements.analytics.moodMetric.textContent = '—';
          }
          if (elements.focus.taskSelect) {
            while (elements.focus.taskSelect.options.length > 1) {
              elements.focus.taskSelect.remove(1);
            }
            elements.focus.taskSelect.value = '';
          }
          focusState.selectedTaskId = '';
          focusState.history = [];
          if (elements.focus.moodSelect) {
            elements.focus.moodSelect.value = 'neutral';
          }
          focusState.selectedMood = 'neutral';
          focusState.durationMinutes = elements.focus.durationInput
            ? clampNumber(Number(elements.focus.durationInput.value) || 25, 5, 90)
            : 25;
          if (elements.focus.durationInput) {
            elements.focus.durationInput.value = focusState.durationMinutes;
          }
          focusState.remainingSeconds = focusState.durationMinutes * 60;
          if (focusState.intervalId) {
            clearInterval(focusState.intervalId);
            focusState.intervalId = null;
          }
          focusState.isRunning = false;
          updateFocusTimerDisplay();
          updateFocusSubtitle();
          updateFocusStatus('ready');
          updateFocusControls();
          updateFocusHistoryUi();
          updateDashboardMetrics();
          renderActivitySnapshot();
        }

        function setMetricOutput(element, value, options = {}) {
          if (!element) return;
          const { isTime = false } = options;
          if (value === null || value === undefined) {
            element.textContent = '—';
            return;
          }
          if (isTime) {
            const minutes = Number(value) || 0;
            element.textContent = minutes ? formatMinutes(minutes) : '0m';
            return;
          }
          if (typeof value === 'number') {
            element.textContent = Number.isFinite(value) ? String(value) : '—';
            return;
          }
          const textValue = String(value).trim();
          element.textContent = textValue ? textValue : '—';
        }

        function setTextContent(element, text) {
          if (!element) return;
          const value = text === undefined || text === null || text === '' ? '—' : String(text);
          element.textContent = value;
        }

        function setMetricDetail(element, text) {
          if (!element) return;
          element.textContent = text && String(text).trim() ? String(text).trim() : 'Awaiting workspace sync.';
        }

        function formatActorLabel(value) {
          if (!value) return '—';
          return String(value).trim();
        }

        function formatActivityAction(action) {
          if (!action) return '—';
          const parts = String(action)
            .split('.')
            .map((part) => toTitleCase(part.replace(/[-_]/g, ' ').trim()))
            .filter(Boolean);
          return parts.length ? parts.join(' · ') : String(action);
        }

        function formatActivityTarget(type, id) {
          const label = type ? toTitleCase(String(type).replace(/[-_]/g, ' ').trim()) : 'Target';
          const identifier = id ? String(id).trim() : '';
          return identifier ? `${label} • ${identifier}` : label;
        }

        function formatRelativeTime(value) {
          const date = parseDate(value);
          if (!date) return '—';
          const diffMs = Date.now() - date.getTime();
          if (!Number.isFinite(diffMs)) return '—';
          if (diffMs <= 0) return 'Just now';
          const diffSeconds = Math.round(diffMs / 1000);
          if (diffSeconds < 45) return 'Just now';
          const diffMinutes = Math.round(diffSeconds / 60);
          if (diffMinutes < 60) return `${diffMinutes}m ago`;
          const diffHours = Math.round(diffMinutes / 60);
          if (diffHours < 24) return `${diffHours}h ago`;
          const diffDays = Math.round(diffHours / 24);
          if (diffDays < 7) return `${diffDays}d ago`;
          const diffWeeks = Math.round(diffDays / 7);
          if (diffWeeks < 4) return `${diffWeeks}w ago`;
          const diffMonths = Math.round(diffDays / 30);
          if (diffMonths < 12) return `${diffMonths}mo ago`;
          const diffYears = Math.round(diffDays / 365);
          return `${diffYears}y ago`;
        }

        function formatDateTime(value) {
          const date = parseDate(value);
          if (!date) return '—';
          return new Intl.DateTimeFormat(undefined, {
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
          }).format(date);
        }

        function formatDisplayFullDate(key) {
          const date = parseDateKeyString(key);
          if (!date) return '';
          return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' });
        }

        function calculateDayDelta(fromDate, toDate) {
          const start = parseDate(fromDate);
          const end = parseDate(toDate);
          if (!start || !end) return 0;
          const startUtc = Date.UTC(start.getFullYear(), start.getMonth(), start.getDate());
          const endUtc = Date.UTC(end.getFullYear(), end.getMonth(), end.getDate());
          const diff = endUtc - startUtc;
          return Math.round(diff / (24 * 60 * 60 * 1000));
        }

        function parseDate(value) {
          if (!value) return null;
          if (value instanceof Date) {
            return Number.isNaN(value.getTime()) ? null : value;
          }
          const parsed = new Date(value);
          return Number.isNaN(parsed.getTime()) ? null : parsed;
        }

        function parseDateKeyString(key) {
          if (!key) return null;
          const parts = String(key).split('-');
          if (parts.length !== 3) return null;
          const year = Number(parts[0]);
          const month = Number(parts[1]);
          const day = Number(parts[2]);
          if (!year || !month || !day) return null;
          const date = new Date(year, month - 1, day);
          return Number.isNaN(date.getTime()) ? null : date;
        }

        function toTitleCase(value) {
          return String(value)
            .split(' ')
            .map((segment) =>
              segment ? segment.charAt(0).toUpperCase() + segment.slice(1).toLowerCase() : ''
            )
            .join(' ');
        }

        function toggleEmptyState(element, shouldShow) {
          if (!element) return;
          element.classList.toggle('hidden', !shouldShow);
          element.classList.toggle('flex', shouldShow);
        }

        function formatDateKey(value) {
          const date = value instanceof Date ? value : new Date(value);
          if (Number.isNaN(date.getTime())) {
            return '';
          }
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, '0');
          const day = String(date.getDate()).padStart(2, '0');
          return `${year}-${month}-${day}`;
        }

        function formatDisplayDate(key) {
          const [year, month, day] = key.split('-');
          const date = new Date(Number(year), Number(month) - 1, Number(day));
          return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
        }

        function formatMinutes(total) {
          const minutes = Math.round(Number(total) || 0);
          if (!minutes) return '0m';
          const hours = Math.floor(minutes / 60);
          const mins = minutes % 60;
          if (hours && mins) return `${hours}h ${mins}m`;
          if (hours) return `${hours}h`;
          return `${mins}m`;
        }

        function resolveMoodScore(label) {
          if (!label) return 3;
          const normalized = String(label).trim().toLowerCase();
          return MOOD_SCORES[normalized] || 3;
        }

        function getTaskNameById(taskId) {
          if (!taskId) return '';
          const tasks = Array.isArray(state.data.tasks) ? state.data.tasks : [];
          const match = tasks.find((task) => task.TaskID === taskId);
          return match ? match.Name || match.TaskID : '';
        }

        function formatHistoryTimestamp(date) {
          if (!(date instanceof Date)) return '';
          return new Intl.DateTimeFormat(undefined, {
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
          }).format(date);
        }

        function escapeHtml(value) {
          return String(value)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
        }

        function clampNumber(value, min, max) {
          return Math.min(Math.max(value, min), max);

        }
      })();

      function showToast(message, type = 'info') {
        const container = document.getElementById('toastStack');
        if (!container) return;
        const toast = document.createElement('div');
        const baseClasses = [
          'pointer-events-auto',

          'rounded-2xl',
          'border',
          'border-white/10',
          'px-4',
          'py-3',
          'shadow-lg',
          'backdrop-blur',
          'text-sm',
          'flex',
          'items-start',
          'gap-3',
          'transition',
        ];
        const palette = {
          success: 'bg-emerald-500/20 text-emerald-100',
          error: 'bg-rose-500/20 text-rose-100',
          info: 'bg-slate-800/80 text-slate-100',
        };
        toast.className = baseClasses.join(' ');
        toast.classList.add('toast-enter');
        toast.innerHTML = `
          <span class="mt-0.5 text-lg">${type === 'success' ? '✅' : type === 'error' ? '⚠️' : 'ℹ️'}</span>
          <div class="leading-snug">
            <p class="font-medium">${message}</p>
          </div>
        `;
        toast.classList.add(...(palette[type] || palette.info).split(' '));

        container.appendChild(toast);
        requestAnimationFrame(() => {
          toast.classList.remove('toast-enter');
          toast.classList.add('toast-enter-active');
        });
        setTimeout(() => {
          toast.classList.remove('toast-enter-active');
          toast.classList.add('toast-leave-active');
          setTimeout(() => {
            toast.remove();
          }, 220);
        }, 3600);

      }
    </script>
  </body>
</html>
